import axios, { AxiosInstance, AxiosResponse } from 'axios';
import {
  BiomniConfig,
  AgentResponse,
  StreamResponse,
  ToolSchema,
  DataLakeItem,
  LibraryItem,
  CustomTool,
  CustomData,
  CustomSoftware,
  AgentInitRequest,
  AgentQueryRequest,
  ToolAddRequest,
  DataAddRequest,
  SoftwareAddRequest,
  MCPAddRequest,
  APIResponse,
  AgentStatus,
  SystemPrompt,
  ToolRegistry,
  RetrieverResult,
} from '@/types/biomni';

// Backend response types that match the actual API
interface BackendChatResponse {
  session_id: string;
  response: string;
  log: string[];
  timestamp: string;
  status: string;
}

interface BackendSystemInfo {
  tools: Array<{
    name: string;
    description: string;
    module: string;
    parameters: Record<string, any>;
  }>;
  data_lake: Array<{
    name: string;
    description: string;
    path: string;
  }>;
  software: Array<{
    name: string;
    description: string;
  }>;
  configuration: Record<string, any>;
}

interface BackendHealthResponse {
  status: string;
  agent_initialized: boolean;
  timestamp: string;
}

class BiomniAPI {
  private client: AxiosInstance;
  private baseURL: string;

  constructor(baseURL: string = 'http://localhost:8000') {
    this.baseURL = baseURL;
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: 300000, // 5 minutes for long-running queries
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Add request interceptor for logging
    this.client.interceptors.request.use(
      (config) => {
        console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);
        return config;
      },
      (error) => {
        console.error('API Request Error:', error);
        return Promise.reject(error);
      }
    );

    // Add response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => {
        return response;
      },
      (error) => {
        console.error('API Response Error:', error);
        if (error.response?.status === 500) {
          throw new Error('Internal server error. Please check the backend logs.');
        }
        throw error;
      }
    );
  }

  // Agent Management
  async initializeAgent(config: AgentInitRequest): Promise<APIResponse<BiomniConfig>> {
    try {
      // Use configure endpoint to update agent settings
      const response: AxiosResponse<{ message: string; timestamp: string }> = await this.client.post('/api/configure', config);
      return {
        success: true,
        data: config as BiomniConfig,
        message: response.data.message
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to initialize agent');
    }
  }

  async queryAgent(request: AgentQueryRequest): Promise<APIResponse<AgentResponse>> {
    try {
      // Convert frontend request to backend format
      const backendRequest = {
        message: request.prompt,
        session_id: undefined, // Will be generated by backend
        use_tool_retriever: true, // Default value
        self_critic: request.self_critic || false
      };

      const response: AxiosResponse<BackendChatResponse> = await this.client.post('/api/chat', backendRequest);
      
      // Convert backend response to frontend format
      return {
        success: true,
        data: {
          log: response.data.log,
          content: response.data.response
        },
        message: `Chat completed successfully. Session: ${response.data.session_id}`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to query agent');
    }
  }

  async streamQuery(request: AgentQueryRequest): Promise<ReadableStream<StreamResponse>> {
    try {
      // Streaming is handled via WebSocket connection
      // This method should not be called directly
      throw new Error('Streaming is handled via WebSocket connection. Use WebSocket client instead.');
    } catch (error) {
      throw this.handleError(error, 'Failed to stream query');
    }
  }

  async getAgentStatus(): Promise<APIResponse<AgentStatus>> {
    try {
      const response: AxiosResponse<BackendHealthResponse> = await this.client.get('/health');
      return {
        success: true,
        data: {
          is_initialized: response.data.agent_initialized,
          is_processing: false, // Not provided by backend
          current_task: undefined,
          error: undefined
        },
        message: `Agent status: ${response.data.status}`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get agent status');
    }
  }

  async getSystemPrompt(): Promise<APIResponse<SystemPrompt>> {
    try {
      // System prompt is not exposed as a separate endpoint in the backend
      // Return a default system prompt
      return {
        success: true,
        data: {
          content: "You are Biomni, a biomedical AI agent specialized in research and analysis.",
          custom_tools: [],
          custom_data: [],
          custom_software: []
        },
        message: "System prompt retrieved successfully"
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get system prompt');
    }
  }

  // Tool Management
  async getToolRegistry(): Promise<APIResponse<ToolRegistry>> {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get('/api/system/info');
      
      // Convert backend tools to frontend format
      const tools: ToolSchema[] = response.data.tools.map(tool => ({
        name: tool.name,
        description: tool.description,
        module: tool.module,
        parameters: tool.parameters,
        required_parameters: [],
        optional_parameters: []
      }));

      return {
        success: true,
        data: {
          tools,
          document_df: null // Not provided by backend
        },
        message: `Retrieved ${tools.length} tools successfully`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get tool registry');
    }
  }

  async getToolsByCategory(): Promise<APIResponse<Record<string, ToolSchema[]>>> {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get('/api/system/info');
      
      // Group tools by module (category)
      const toolsByCategory: Record<string, ToolSchema[]> = {};
      response.data.tools.forEach(tool => {
        const category = tool.module;
        if (!toolsByCategory[category]) {
          toolsByCategory[category] = [];
        }
        toolsByCategory[category].push({
          name: tool.name,
          description: tool.description,
          module: tool.module,
          parameters: tool.parameters,
          required_parameters: [],
          optional_parameters: []
        });
      });

      return {
        success: true,
        data: toolsByCategory,
        message: `Retrieved tools by category successfully`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get tools by category');
    }
  }

  async addCustomTool(tool: ToolAddRequest): Promise<APIResponse<ToolSchema>> {
    try {
      const response: AxiosResponse<{ message: string; timestamp: string }> = await this.client.post('/api/tools/add', tool);
      return {
        success: true,
        data: {
          name: tool.name,
          description: tool.description,
          module: tool.module,
          parameters: {},
          required_parameters: tool.required_parameters,
          optional_parameters: tool.optional_parameters
        },
        message: response.data.message
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to add custom tool');
    }
  }

  async removeCustomTool(name: string): Promise<APIResponse<boolean>> {
    try {
      // Custom tool removal is not implemented in the backend yet
      throw new Error('Custom tool removal not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to remove custom tool');
    }
  }

  async getCustomTools(): Promise<APIResponse<CustomTool[]>> {
    try {
      const response: AxiosResponse<{ custom_tools: any[]; timestamp: string }> = await this.client.get('/api/tools/custom');
      return {
        success: true,
        data: response.data.custom_tools,
        message: `Retrieved ${response.data.custom_tools.length} custom tools`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get custom tools');
    }
  }

  // Data Lake Management
  async getDataLake(): Promise<APIResponse<DataLakeItem[]>> {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get('/api/system/info');
      
      // Convert backend data lake items to frontend format
      const dataLakeItems: DataLakeItem[] = response.data.data_lake.map(item => ({
        name: item.name,
        description: item.description,
        path: item.path
      }));

      return {
        success: true,
        data: dataLakeItems,
        message: `Retrieved ${dataLakeItems.length} data lake items`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get data lake');
    }
  }

  async addCustomData(data: DataAddRequest): Promise<APIResponse<CustomData>> {
    try {
      // This method is now handled by the upload modal directly
      // The upload modal makes the API call to /api/data/upload
      throw new Error('Use the upload modal to add custom data files');
    } catch (error) {
      throw this.handleError(error, 'Failed to add custom data');
    }
  }

  async removeCustomData(name: string): Promise<APIResponse<boolean>> {
    try {
      // Custom data removal is not implemented in the backend yet
      throw new Error('Custom data removal not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to remove custom data');
    }
  }

  async getCustomData(): Promise<APIResponse<CustomData[]>> {
    try {
      // Custom data retrieval is not implemented in the backend yet
      throw new Error('Custom data retrieval not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to get custom data');
    }
  }

  // Software Library Management
  async getSoftwareLibrary(): Promise<APIResponse<LibraryItem[]>> {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get('/api/system/info');
      
      // Convert backend software to frontend format
      const softwareItems: LibraryItem[] = response.data.software.map(item => ({
        name: item.name,
        description: item.description
      }));

      return {
        success: true,
        data: softwareItems,
        message: `Retrieved ${softwareItems.length} software items`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get software library');
    }
  }

  async addCustomSoftware(software: SoftwareAddRequest): Promise<APIResponse<CustomSoftware>> {
    try {
      // Custom software addition is not implemented in the backend yet
      throw new Error('Custom software addition not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to add custom software');
    }
  }

  async removeCustomSoftware(name: string): Promise<APIResponse<boolean>> {
    try {
      // Custom software removal is not implemented in the backend yet
      throw new Error('Custom software removal not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to remove custom software');
    }
  }

  async getCustomSoftware(): Promise<APIResponse<CustomSoftware[]>> {
    try {
      // Custom software retrieval is not implemented in the backend yet
      throw new Error('Custom software retrieval not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to get custom software');
    }
  }

  // MCP Integration
  async addMCP(config: MCPAddRequest): Promise<APIResponse<void>> {
    try {
      // MCP integration is not implemented in the backend yet
      throw new Error('MCP integration not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to add MCP server');
    }
  }

  async createMCPServer(toolModules?: string[]): Promise<APIResponse<string>> {
    try {
      // MCP server creation is not implemented in the backend yet
      throw new Error('MCP server creation not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to create MCP server');
    }
  }

  // Configuration Management
  async getConfiguration(): Promise<APIResponse<BiomniConfig>> {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get('/api/system/info');
      
      // Convert backend configuration to frontend format
      const config: BiomniConfig = {
        path: response.data.configuration.path || '',
        timeout_seconds: response.data.configuration.timeout_seconds || 300,
        llm: response.data.configuration.llm || 'Unknown',
        temperature: response.data.configuration.temperature, // Not provided by backend
        use_tool_retriever: response.data.configuration.use_tool_retriever || true,
        source: response.data.configuration.source || 'Unknown'
      };

      return {
        success: true,
        data: config,
        message: 'Configuration retrieved successfully'
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get configuration');
    }
  }

  async updateConfiguration(config: Partial<BiomniConfig>): Promise<APIResponse<BiomniConfig>> {
    try {
      // Convert frontend config to backend format
      const backendConfig = {
        llm: config.llm,
        source: config.source,
        use_tool_retriever: config.use_tool_retriever,
        timeout_seconds: config.timeout_seconds,
        base_url: config.base_url,
        api_key: config.api_key
      };

      const response: AxiosResponse<{ message: string; timestamp: string }> = await this.client.post('/api/configure', backendConfig);
      
      return {
        success: true,
        data: config as BiomniConfig,
        message: response.data.message
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to update configuration');
    }
  }

  // Resource Retrieval
  async retrieveResources(query: string): Promise<APIResponse<RetrieverResult>> {
    try {
      // Resource retrieval is not implemented in the backend yet
      throw new Error('Resource retrieval not yet implemented in backend');
    } catch (error) {
      throw this.handleError(error, 'Failed to retrieve resources');
    }
  }

  // Health Check
  async healthCheck(): Promise<APIResponse<{ status: string; timestamp: string }>> {
    try {
      const response: AxiosResponse<BackendHealthResponse> = await this.client.get('/health');
      return {
        success: true,
        data: {
          status: response.data.status,
          timestamp: response.data.timestamp
        },
        message: `Health check successful. Agent initialized: ${response.data.agent_initialized}`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to perform health check');
    }
  }

  // Sessions Management
  async getSessions(): Promise<APIResponse<{ sessions: Record<string, any>; total_sessions: number; timestamp: string }>> {
    try {
      const response: AxiosResponse<{ sessions: Record<string, any>; total_sessions: number; timestamp: string }> = await this.client.get('/api/sessions');
      return {
        success: true,
        data: response.data,
        message: `Retrieved ${response.data.total_sessions} active sessions`
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to get sessions');
    }
  }

  async deleteSession(sessionId: string): Promise<APIResponse<{ message: string }>> {
    try {
      const response: AxiosResponse<{ message: string }> = await this.client.delete(`/api/sessions/${sessionId}`);
      return {
        success: true,
        data: response.data,
        message: response.data.message
      };
    } catch (error) {
      throw this.handleError(error, 'Failed to delete session');
    }
  }

  // Error handling helper
  private handleError(error: any, defaultMessage: string): Error {
    if (error.response?.data?.error) {
      return new Error(error.response.data.error);
    }
    if (error.response?.data?.detail) {
      return new Error(error.response.data.detail);
    }
    if (error.message) {
      return new Error(error.message);
    }
    return new Error(defaultMessage);
  }

  // Utility method to check if the API is available
  async isAvailable(): Promise<boolean> {
    try {
      await this.healthCheck();
      return true;
    } catch {
      return false;
    }
  }
}

// Export a singleton instance
export const biomniAPI = new BiomniAPI();

// Export the class for testing or custom instances
export { BiomniAPI };

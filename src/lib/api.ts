import axios, { AxiosInstance, AxiosResponse } from "axios";
import {
  BiomniConfig,
  AgentResponse,
  StreamResponse,
  ToolSchema,
  DataLakeItem,
  LibraryItem,
  CustomTool,
  CustomData,
  CustomSoftware,
  AgentInitRequest,
  AgentQueryRequest,
  ToolAddRequest,
  DataAddRequest,
  SoftwareAddRequest,
  MCPAddRequest,
  APIResponse,
  AgentStatus,
  SystemPrompt,
  ToolRegistry,
  RetrieverResult,
  WebSocketConfig,
  BackendWebSocketMessage,
} from "@/types/biomni";

// Backend response types that match the actual API
interface BackendChatResponse {
  session_id: string;
  response: string;
  log: string[];
  timestamp: string;
  status: string;
}

interface BackendSystemInfo {
  tools: Array<{
    name: string;
    description: string;
    module: string;
    parameters: Record<string, any>;
  }>;
  data_lake: Array<{
    name: string;
    description: string;
    path: string;
  }>;
  software: Array<{
    name: string;
    description: string;
  }>;
  configuration: Record<string, any>;
}

interface BackendHealthResponse {
  status: string;
  agent_initialized: boolean;
  timestamp: string;
}

class BiomniAPI {
  private client: AxiosInstance;
  private baseURL: string;

  constructor(baseURL?: string) {
    // Use environment variable for production, fallback to Vercel proxy for production
    const isProduction = window.location.hostname.includes("vercel.app");
    const defaultUrl = isProduction
      ? "/api/proxy" // Use Vercel proxy route for production
      : "http://localhost:8000";
    // : 'https://api.mybioai.net'

    this.baseURL = baseURL || import.meta.env.VITE_API_BASE_URL || defaultUrl;

    // Debug logging
    console.log("API Base URL:", this.baseURL);
    console.log(
      "Environment VITE_API_BASE_URL:",
      import.meta.env.VITE_API_BASE_URL
    );
    console.log("Is Production:", isProduction);

    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: 300000, // 5 minutes for long-running queries
      headers: {
        "Content-Type": "application/json",
        "ngrok-skip-browser-warning": "69420",
      },
    });

    // Add request interceptor for logging
    this.client.interceptors.request.use(
      (config) => {
        console.log(
          `API Request: ${config.method?.toUpperCase()} ${config.url}`
        );
        return config;
      },
      (error) => {
        console.error("API Request Error:", error);
        return Promise.reject(error);
      }
    );

    // Add response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => {
        return response;
      },
      (error) => {
        console.error("API Response Error:", error);
        if (error.response?.status === 500) {
          throw new Error(
            "Internal server error. Please check the backend logs."
          );
        }
        throw error;
      }
    );
  }

  // Agent Management
  async initializeAgent(
    config: AgentInitRequest
  ): Promise<APIResponse<BiomniConfig>> {
    try {
      // Use configure endpoint to update agent settings
      const response: AxiosResponse<{ message: string; timestamp: string }> =
        await this.client.post("/api/configure", config);
      return {
        success: true,
        data: config as BiomniConfig,
        message: response.data.message,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to initialize agent");
    }
  }

  async queryAgent(
    request: AgentQueryRequest
  ): Promise<APIResponse<AgentResponse>> {
    try {
      // Convert frontend request to backend format
      const backendRequest = {
        message: request.prompt,
        session_id: undefined, // Will be generated by backend
        use_tool_retriever: true, // Default value
        self_critic: request.self_critic || false,
      };

      const response: AxiosResponse<BackendChatResponse> =
        await this.client.post("/api/chat", backendRequest);

      // Convert backend response to frontend format
      return {
        success: true,
        data: {
          log: response.data.log,
          content: response.data.response,
        },
        message: `Chat completed successfully. Session: ${response.data.session_id}`,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to query agent");
    }
  }

  async streamQuery(
    _request: AgentQueryRequest
  ): Promise<ReadableStream<StreamResponse>> {
    try {
      // Streaming is handled via WebSocket connection
      // This method should not be called directly
      throw new Error(
        "Streaming is handled via WebSocket connection. Use WebSocket client instead."
      );
    } catch (error) {
      throw this.handleError(error, "Failed to stream query");
    }
  }

  async getAgentStatus(): Promise<APIResponse<AgentStatus>> {
    try {
      const response: AxiosResponse<BackendHealthResponse> =
        await this.client.get("/health");
      return {
        success: true,
        data: {
          is_initialized: response.data.agent_initialized,
          is_processing: false, // Not provided by backend
          current_task: undefined,
          error: undefined,
        },
        message: `Agent status: ${response.data.status}`,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to get agent status");
    }
  }

  async getSystemPrompt(): Promise<APIResponse<SystemPrompt>> {
    try {
      // System prompt is not exposed as a separate endpoint in the backend
      // Return a default system prompt
      return {
        success: true,
        data: {
          content:
            "You are MyBioAI, a biomedical AI agent specialized in research and analysis.",
          custom_tools: [],
          custom_data: [],
          custom_software: [],
        },
        message: "System prompt retrieved successfully",
      };
    } catch (error) {
      throw this.handleError(error, "Failed to get system prompt");
    }
  }

  // Tool Management
  async getToolRegistry(): Promise<APIResponse<ToolRegistry>> {
    try {
      console.log(
        "Fetching tool registry from:",
        `${this.baseURL}/api/system/info`
      );
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get(
        "/api/system/info"
      );
      console.log("Tool registry response:", response.data);

      // Check if response.data exists and has the expected structure
      if (!response.data) {
        throw new Error("No data received from backend");
      }

      if (!response.data.tools || !Array.isArray(response.data.tools)) {
        console.error("Unexpected response structure:", response.data);
        throw new Error("Backend response does not contain tools array");
      }

      // Convert backend tools to frontend format
      const tools: ToolSchema[] = response.data.tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        module: tool.module,
        parameters: tool.parameters,
        required_parameters: [],
        optional_parameters: [],
      }));

      return {
        success: true,
        data: {
          tools,
          document_df: null, // Not provided by backend
        },
        message: `Retrieved ${tools.length} tools successfully`,
      };
    } catch (error) {
      console.error("Error fetching tool registry:", error);
      throw this.handleError(error, "Failed to get tool registry");
    }
  }

  async getToolsByCategory(): Promise<
    APIResponse<Record<string, ToolSchema[]>>
  > {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get(
        "/api/system/info"
      );

      // Group tools by module (category)
      const toolsByCategory: Record<string, ToolSchema[]> = {};
      response.data.tools.forEach((tool) => {
        const category = tool.module;
        if (!toolsByCategory[category]) {
          toolsByCategory[category] = [];
        }
        toolsByCategory[category].push({
          name: tool.name,
          description: tool.description,
          module: tool.module,
          parameters: tool.parameters,
          required_parameters: [],
          optional_parameters: [],
        });
      });

      return {
        success: true,
        data: toolsByCategory,
        message: `Retrieved tools by category successfully`,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to get tools by category");
    }
  }

  async addCustomTool(tool: ToolAddRequest): Promise<APIResponse<ToolSchema>> {
    try {
      const response: AxiosResponse<{ message: string; timestamp: string }> =
        await this.client.post("/api/tools/add", tool);
      return {
        success: true,
        data: {
          name: tool.name,
          description: tool.description,
          module: tool.module,
          parameters: {},
          required_parameters: tool.required_parameters,
          optional_parameters: tool.optional_parameters,
        },
        message: response.data.message,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to add custom tool");
    }
  }

  async removeCustomTool(_name: string): Promise<APIResponse<boolean>> {
    try {
      // Custom tool removal is not implemented in the backend yet
      throw new Error("Custom tool removal not yet implemented in backend");
    } catch (error) {
      throw this.handleError(error, "Failed to remove custom tool");
    }
  }

  async getCustomTools(): Promise<APIResponse<CustomTool[]>> {
    try {
      const response: AxiosResponse<{
        custom_tools: any[];
        timestamp: string;
      }> = await this.client.get("/api/tools/custom");
      return {
        success: true,
        data: response.data.custom_tools,
        message: `Retrieved ${response.data.custom_tools.length} custom tools`,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to get custom tools");
    }
  }

  // Data Lake Management
  async getDataLake(): Promise<APIResponse<DataLakeItem[]>> {
    try {
      console.log(
        "Fetching data lake from:",
        `${this.baseURL}/api/system/info`
      );
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get(
        "/api/system/info"
      );
      console.log("Data lake response:", response.data);

      // Check if response.data exists and has the expected structure
      if (!response.data) {
        throw new Error("No data received from backend");
      }

      if (!response.data.data_lake || !Array.isArray(response.data.data_lake)) {
        console.error("Unexpected response structure:", response.data);
        throw new Error("Backend response does not contain data_lake array");
      }

      // Convert backend data lake items to frontend format
      const dataLakeItems: DataLakeItem[] = response.data.data_lake.map(
        (item) => ({
          name: item.name,
          description: item.description,
          path: item.path,
        })
      );

      return {
        success: true,
        data: dataLakeItems,
        message: `Retrieved ${dataLakeItems.length} data lake items`,
      };
    } catch (error) {
      console.error("Error fetching data lake:", error);
      throw this.handleError(error, "Failed to get data lake");
    }
  }

  async addCustomData(_data: DataAddRequest): Promise<APIResponse<CustomData>> {
    try {
      // This method is now handled by the upload modal directly
      // The upload modal makes the API call to /api/data/upload
      throw new Error("Use the upload modal to add custom data files");
    } catch (error) {
      throw this.handleError(error, "Failed to add custom data");
    }
  }

  async removeCustomData(_name: string): Promise<APIResponse<boolean>> {
    try {
      // Custom data removal is not implemented in the backend yet
      throw new Error("Custom data removal not yet implemented in backend");
    } catch (error) {
      throw this.handleError(error, "Failed to remove custom data");
    }
  }

  async getCustomData(): Promise<APIResponse<CustomData[]>> {
    try {
      // Custom data retrieval is not implemented in the backend yet
      throw new Error("Custom data retrieval not yet implemented in backend");
    } catch (error) {
      throw this.handleError(error, "Failed to get custom data");
    }
  }

  // Software Library Management
  async getSoftwareLibrary(): Promise<APIResponse<LibraryItem[]>> {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get(
        "/api/system/info"
      );

      // Convert backend software to frontend format
      const softwareItems: LibraryItem[] = response.data.software.map(
        (item) => ({
          name: item.name,
          description: item.description,
        })
      );

      return {
        success: true,
        data: softwareItems,
        message: `Retrieved ${softwareItems.length} software items`,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to get software library");
    }
  }

  async addCustomSoftware(
    _software: SoftwareAddRequest
  ): Promise<APIResponse<CustomSoftware>> {
    try {
      // Custom software addition is not implemented in the backend yet
      throw new Error(
        "Custom software addition not yet implemented in backend"
      );
    } catch (error) {
      throw this.handleError(error, "Failed to add custom software");
    }
  }

  async removeCustomSoftware(_name: string): Promise<APIResponse<boolean>> {
    try {
      // Custom software removal is not implemented in the backend yet
      throw new Error("Custom software removal not yet implemented in backend");
    } catch (error) {
      throw this.handleError(error, "Failed to remove custom software");
    }
  }

  async getCustomSoftware(): Promise<APIResponse<CustomSoftware[]>> {
    try {
      // Custom software retrieval is not implemented in the backend yet
      throw new Error(
        "Custom software retrieval not yet implemented in backend"
      );
    } catch (error) {
      throw this.handleError(error, "Failed to get custom software");
    }
  }

  // MCP Integration
  async addMCP(_config: MCPAddRequest): Promise<APIResponse<void>> {
    try {
      // MCP integration is not implemented in the backend yet
      throw new Error("MCP integration not yet implemented in backend");
    } catch (error) {
      throw this.handleError(error, "Failed to add MCP server");
    }
  }

  async createMCPServer(_toolModules?: string[]): Promise<APIResponse<string>> {
    try {
      // MCP server creation is not implemented in the backend yet
      throw new Error("MCP server creation not yet implemented in backend");
    } catch (error) {
      throw this.handleError(error, "Failed to create MCP server");
    }
  }

  // Configuration Management
  async getConfiguration(): Promise<APIResponse<BiomniConfig>> {
    try {
      const response: AxiosResponse<BackendSystemInfo> = await this.client.get(
        "/api/system/info"
      );

      // Convert backend configuration to frontend format
      const config: BiomniConfig = {
        path: response.data.configuration.path || "",
        timeout_seconds: response.data.configuration.timeout_seconds || 300,
        llm: response.data.configuration.llm || "Unknown",
        temperature: response.data.configuration.temperature, // Not provided by backend
        use_tool_retriever:
          response.data.configuration.use_tool_retriever || true,
        source: response.data.configuration.source || "Unknown",
      };

      return {
        success: true,
        data: config,
        message: "Configuration retrieved successfully",
      };
    } catch (error) {
      throw this.handleError(error, "Failed to get configuration");
    }
  }

  async updateConfiguration(
    config: Partial<BiomniConfig>
  ): Promise<APIResponse<BiomniConfig>> {
    try {
      // Convert frontend config to backend format
      const backendConfig = {
        llm: config.llm,
        source: config.source,
        use_tool_retriever: config.use_tool_retriever,
        timeout_seconds: config.timeout_seconds,
        base_url: config.base_url,
        api_key: config.api_key,
      };

      const response: AxiosResponse<{ message: string; timestamp: string }> =
        await this.client.post("/api/configure", backendConfig);

      return {
        success: true,
        data: config as BiomniConfig,
        message: response.data.message,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to update configuration");
    }
  }

  // Resource Retrieval
  async retrieveResources(
    _query: string
  ): Promise<APIResponse<RetrieverResult>> {
    try {
      // Resource retrieval is not implemented in the backend yet
      throw new Error("Resource retrieval not yet implemented in backend");
    } catch (error) {
      throw this.handleError(error, "Failed to retrieve resources");
    }
  }

  // Health Check
  async healthCheck(): Promise<
    APIResponse<{ status: string; timestamp: string }>
  > {
    try {
      console.log("Performing health check on:", `${this.baseURL}/health`);
      const response: AxiosResponse<BackendHealthResponse> =
        await this.client.get("/health");
      console.log("Health check response:", response.data);
      return {
        success: true,
        data: {
          status: response.data.status,
          timestamp: response.data.timestamp,
        },
        message: `Health check successful. Agent initialized: ${response.data.agent_initialized}`,
      };
    } catch (error) {
      console.error("Health check failed:", error);
      throw this.handleError(error, "Failed to perform health check");
    }
  }

  // Simple connectivity test
  async testConnectivity(): Promise<boolean> {
    try {
      await this.healthCheck();
      return true;
    } catch (error) {
      console.error("Connectivity test failed:", error);
      return false;
    }
  }

  // Sessions Management
  async getSessions(): Promise<
    APIResponse<{
      sessions: Record<string, any>;
      total_sessions: number;
      timestamp: string;
    }>
  > {
    try {
      const response: AxiosResponse<{
        sessions: Record<string, any>;
        total_sessions: number;
        timestamp: string;
      }> = await this.client.get("/api/sessions");
      return {
        success: true,
        data: response.data,
        message: `Retrieved ${response.data.total_sessions} active sessions`,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to get sessions");
    }
  }

  async deleteSession(
    sessionId: string
  ): Promise<APIResponse<{ message: string }>> {
    try {
      const response: AxiosResponse<{ message: string }> =
        await this.client.delete(`/api/sessions/${sessionId}`);
      return {
        success: true,
        data: response.data,
        message: response.data.message,
      };
    } catch (error) {
      throw this.handleError(error, "Failed to delete session");
    }
  }

  // WebSocket Streaming
  createWebSocketConnection(config: WebSocketConfig): WebSocket {
    // Determine WebSocket URL based on environment
    const isProduction =
      window.location.protocol === "https:" ||
      window.location.hostname.includes("vercel.app") ||
      window.location.hostname.includes("mybioai.net") ||
      window.location.hostname !== "localhost";

    const wsBaseURL = isProduction
      ? "wss://api.mybioai.net" // Use secure WebSocket for production API
      : "ws://18.212.99.49"; // Use insecure WebSocket for local development

    const wsURL = `${wsBaseURL}/api/chat/stream/${config.sessionId}`;

    // Log WebSocket connection details for debugging
    console.log(
      `WebSocket connecting to: ${wsURL} (Production: ${isProduction})`
    );

    const ws = new WebSocket(wsURL);

    const connectionTimeout = setTimeout(() => {
      ws.close();
      if (config.onError) {
        config.onError({
          type: "error",
          data: {
            message: "WebSocket connection timed out after 10 seconds",
            code: "TIMEOUT",
          },
          timestamp: new Date().toISOString(),
        });
      }
    }, 10000);

    ws.onopen = () => {
      clearTimeout(connectionTimeout);
    };

    ws.onmessage = (event) => {
      try {
        const message: BackendWebSocketMessage = JSON.parse(event.data);

        // Handle backend message format - always log the output
        if (config.onLog) {
          config.onLog({
            type: "log",
            data: {
              message: message.output,
              level: "info",
            },
            timestamp: message.timestamp,
          });
        }

        // Only trigger completion if the backend explicitly says it's complete
        if (message.is_complete === true && config.onComplete) {
          config.onComplete({
            type: "complete",
            data: {
              session_id: message.session_id,
              total_logs: message.step,
              final_output: message.output,
            },
            timestamp: message.timestamp,
          });
        }
      } catch (error) {
        if (config.onError) {
          config.onError({
            type: "error",
            data: {
              message: "Failed to parse WebSocket message",
              code: "PARSE_ERROR",
            },
            timestamp: new Date().toISOString(),
          });
        }
      }
    };

    ws.onerror = () => {
      clearTimeout(connectionTimeout);
      if (config.onError) {
        config.onError({
          type: "error",
          data: {
            message: "WebSocket connection error",
            code: "CONNECTION_ERROR",
          },
          timestamp: new Date().toISOString(),
        });
      }
    };

    ws.onclose = () => {
      clearTimeout(connectionTimeout);
      if (config.onClose) {
        config.onClose();
      }
    };

    return ws;
  }

  // Send message through WebSocket
  sendWebSocketMessage(ws: WebSocket, message: AgentQueryRequest): void {
    if (ws.readyState === WebSocket.OPEN) {
      const payload = {
        message: message.prompt,
        self_critic: message.self_critic || false,
        use_tool_retriever: true,
      };
      ws.send(JSON.stringify(payload));
    } else {
      throw new Error("WebSocket is not open");
    }
  }

  // Close WebSocket connection
  closeWebSocketConnection(ws: WebSocket): void {
    if (ws.readyState === WebSocket.OPEN) {
      ws.close(1000, "Connection closed by client");
    }
  }

  // Error handling helper
  private handleError(error: any, defaultMessage: string): Error {
    if (error.response?.data?.error) {
      return new Error(error.response.data.error);
    }
    if (error.response?.data?.detail) {
      return new Error(error.response.data.detail);
    }
    if (error.message) {
      return new Error(error.message);
    }
    return new Error(defaultMessage);
  }

  // Utility method to check if the API is available
  async isAvailable(): Promise<boolean> {
    try {
      await this.healthCheck();
      return true;
    } catch {
      return false;
    }
  }
}

// Export a singleton instance
export const biomniAPI = new BiomniAPI();

// Export the class for testing or custom instances
export { BiomniAPI };
